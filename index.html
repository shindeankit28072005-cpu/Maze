<!DOCTYPE html><html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Maze Grow Animation</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
}
canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas><script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Maze settings
const cols = 25;
const rows = 40;
const cellSize = Math.min(canvas.width/cols, canvas.height/rows);

let grid = [];
let stack = [];
let current;

class Cell {
  constructor(i,j){
    this.i=i; this.j=j;
    this.walls=[true,true,true,true]; // top right bottom left
    this.visited=false;
  }
  draw(){
    const x=this.i*cellSize;
    const y=this.j*cellSize;
    ctx.strokeStyle='#ff7aa2';
    ctx.lineWidth=2;
    if(this.walls[0]){ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x+cellSize,y);ctx.stroke();}
    if(this.walls[1]){ctx.beginPath();ctx.moveTo(x+cellSize,y);ctx.lineTo(x+cellSize,y+cellSize);ctx.stroke();}
    if(this.walls[2]){ctx.beginPath();ctx.moveTo(x+cellSize,y+cellSize);ctx.lineTo(x,y+cellSize);ctx.stroke();}
    if(this.walls[3]){ctx.beginPath();ctx.moveTo(x,y+cellSize);ctx.lineTo(x,y);ctx.stroke();}
  }
  highlight(){
    const x=this.i*cellSize;
    const y=this.j*cellSize;
    ctx.fillStyle='#ff4f81';
    ctx.fillRect(x,y,cellSize,cellSize);
  }
  checkNeighbors(){
    const neighbors=[];
    const top=grid[index(this.i,this.j-1)];
    const right=grid[index(this.i+1,this.j)];
    const bottom=grid[index(this.i,this.j+1)];
    const left=grid[index(this.i-1,this.j)];
    if(top && !top.visited) neighbors.push(top);
    if(right && !right.visited) neighbors.push(right);
    if(bottom && !bottom.visited) neighbors.push(bottom);
    if(left && !left.visited) neighbors.push(left);
    if(neighbors.length>0){
      return neighbors[Math.floor(Math.random()*neighbors.length)];
    }
    return undefined;
  }
}

function index(i,j){
  if(i<0||j<0||i>=cols||j>=rows) return -1;
  return i+j*cols;
}

function removeWalls(a,b){
  const x=a.i-b.i;
  const y=a.j-b.j;
  if(x===1){a.walls[3]=false; b.walls[1]=false;}
  else if(x===-1){a.walls[1]=false; b.walls[3]=false;}
  if(y===1){a.walls[0]=false; b.walls[2]=false;}
  else if(y===-1){a.walls[2]=false; b.walls[0]=false;}
}

for(let j=0;j<rows;j++){
  for(let i=0;i<cols;i++){
    grid.push(new Cell(i,j));
  }
}

current = grid[0];

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  grid.forEach(c=>c.draw());

  current.visited=true;
  current.highlight();
  const next=current.checkNeighbors();
  if(next){
    next.visited=true;
    stack.push(current);
    removeWalls(current,next);
    current=next;
  } else if(stack.length>0){
    current=stack.pop();
  }

  requestAnimationFrame(animate);
}

animate();
</script></body>
</html>